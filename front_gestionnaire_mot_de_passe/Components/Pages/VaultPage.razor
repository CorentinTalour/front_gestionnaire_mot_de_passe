@page "/VaultPage/{id:int}"

@using front_gestionnaire_mot_de_passe.Components.Displayer
@using front_gestionnaire_mot_de_passe.Components.CreateVaultEntryModal
@using front_gestionnaire_mot_de_passe.Models
@using front_gestionnaire_mot_de_passe.Components.DeleteVaultModal
@using front_gestionnaire_mot_de_passe.Components.EditMembers
@using front_gestionnaire_mot_de_passe.Components.OpenVaultModal
@using front_gestionnaire_mot_de_passe.Components.UpdateVaultModal
@using front_gestionnaire_mot_de_passe.Models.VaultMembers
@inject Microsoft.Identity.Abstractions.IDownstreamApi DownstreamApi
@inject NavigationManager Navigation
@inject Interop.CryptoInterop Crypto
@rendermode InteractiveServer


    <PageTitle>D√©tails du coffre</PageTitle>


    <section class="menu_vault">
        <div class="menu_vault_top">
            <button type="button" class="menu_button_create" @onclick="ShowModal">+</button>            
            <CreateVaultEntryModal IsVisible="@_isModalVisible"
                                   VaultId="@Id"
                                   OnClose="HideModal"
                                   OnCreated="ReloadEntriesAsync" />
            
            @if (VaultData != null && VaultData.IsOwner)
            {
                <button @onclick="() => _isEditingMembers = true" class="menu_button_share">G√©rer les membres</button>
            }
        </div>

        <h2 class="menu_title">Votre coffre fort @(VaultData?.Name)</h2>

        <div class="menu_vault_bottom">
            
        @if (VaultData != null && VaultData.IsOwner)
        {
            <button class="menu_button_update_vault"
                    @onclick="ShowUpdateVaultModal">
                Modifier coffre
            </button>
        }
        
        @if (VaultData != null && VaultData.IsOwner)
        {
            <button type="button" class="menu_button_delete_vault" @onclick="ShowDeleteModal">Supprimer coffre-fort</button>
        }
        </div>
    </section>
    
    <h3 class="vault_title">Liste des mots de passe</h3>

    <UpdateVaultModal IsVisible="@_isUpdateVaultModalVisible"
                      VaultId="@Id"
                      OnClose="HideUpdateVaultModal"
                      OnUpdated="OnVaultUpdated" />

    @if (_isEditingMembers)
    {
        <ModalEditMembers VaultId="@Id" OnClose="@(() => _isEditingMembers = false)" />
    }
    
<section class="display_entries_zone">
    @if (_entries is null)
    {
        <p>Chargement‚Ä¶</p>
    }
    else if (_entries.Count == 0)
    {
        <p>Aucune entr√©e.</p>
    }
    else
    {
        @foreach (var e in _entries)
        {
            <Displayer Entry="e" VaultId="@Id" OnDeleted="ReloadEntriesAsync" OnUpdated="ReloadEntriesAsync" IsOwner="@(VaultData?.IsOwner ?? false)"/>
        }
    }
</section>

    <DeleteVaultModal IsVisible="@_isDeleteModalVisible"
                      OnClose="HideDeleteModal"
                      OnConfirm="DeleteVault" />

@if (_isReopenModalVisible)
{
    <OpenVaultModal IsVisible="true"
                    VaultId="@Id"
                    VaultData="@VaultData"
                    VaultSalt="@VaultData?.Salt"
                    VaultIterations="@VaultData?.NbIteration"
                    OnClose="OnReopenModalClose" />
}

@code {
    [Parameter] public int Id { get; set; }
    private Vault? VaultData { get; set; }
   
    private bool _isModalVisible;
    private bool _isDeleteModalVisible;
    private bool _isReopenModalVisible;
    private List<VaultEntry>? _entries;
    private bool _isUpdateVaultModalVisible;
    private bool _isEditingMembers;


    private void ShowModal()
    {
        _isModalVisible = true;
    }
    
    private void HideModal() => _isModalVisible = false;
    
    private void ShowUpdateVaultModal()
    {
        _isUpdateVaultModalVisible = true;
    }
    
    private void HideUpdateVaultModal()
    {
        _isUpdateVaultModalVisible = false;
    }

    protected override async Task OnInitializedAsync()
    {
        // R√©cup√©rer l'ID de l'utilisateur connect√©
        int? currentUserId = null;
        try
        {
            // Appel √† l'API /Users/Me qui retourne directement l'utilisateur connect√©
            var me = await DownstreamApi.GetForUserAsync<GetUserObj>(
                "DownstreamApi",
                o => o.RelativePath = "/Users/Me"
            );
            
            Console.WriteLine($"[DEBUG] R√©ponse de /Users/Me : {System.Text.Json.JsonSerializer.Serialize(me)}");
            
            if (me != null)
            {
                currentUserId = me.Id;
                Console.WriteLine($"[DEBUG] ‚úÖ Utilisateur connect√© trouv√© - ID: {currentUserId}, Email: {me.Email}");
            }
            else
            {
                Console.WriteLine($"[ERROR] ‚ùå /Users/Me n'a retourn√© aucun utilisateur");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[ERROR] ‚ùå Erreur lors de la r√©cup√©ration de l'utilisateur connect√© : {ex.Message}");
            Console.WriteLine($"[ERROR] Stack trace : {ex.StackTrace}");
        }
        
        // R√©cup√©rer tous les coffres (propri√©taire + membre)
        var allVaults = await DownstreamApi.GetForUserAsync<List<Vault>>(
            "DownstreamApi",
            o => o.RelativePath = "/Vault/All"
        ) ?? new();
        
        Console.WriteLine($"[DEBUG] Nombre de coffres r√©cup√©r√©s : {allVaults.Count}");

        VaultData = allVaults.FirstOrDefault(v => v.Id == Id);
        
        if (VaultData != null)
        {
            Console.WriteLine($"[DEBUG] üì¶ Coffre trouv√© - ID: {VaultData.Id}, Nom: {VaultData.Name}, UserId (propri√©taire): {VaultData.UserId}");
        }
        else
        {
            Console.WriteLine($"[ERROR] ‚ùå Aucun coffre trouv√© avec l'ID {Id}");
        }

        _entries = await DownstreamApi.GetForUserAsync<List<VaultEntry>>(
            "DownstreamApi",
            o => o.RelativePath = $"/Entry/VaultId?vaultId={Id}"
        ) ?? new();

        if (VaultData != null && currentUserId.HasValue)
        {
            // Comparer l'ID du cr√©ateur du coffre avec l'ID de l'utilisateur connect√©
            VaultData.IsOwner = (VaultData.UserId == currentUserId.Value);
            
            Console.WriteLine($"[DEBUG] üîç Comparaison des IDs :");
            Console.WriteLine($"[DEBUG]    - VaultData.UserId (propri√©taire du coffre) : {VaultData.UserId}");
            Console.WriteLine($"[DEBUG]    - currentUserId (utilisateur connect√©)     : {currentUserId.Value}");
            Console.WriteLine($"[DEBUG]    - VaultData.UserId == currentUserId        : {VaultData.UserId == currentUserId.Value}");
            Console.WriteLine($"[DEBUG] ‚û°Ô∏è  IsOwner final : {VaultData.IsOwner}");
        }
        else if (VaultData != null)
        {
            VaultData.IsOwner = false;
            Console.WriteLine($"[WARNING] ‚ö†Ô∏è  Impossible de d√©terminer IsOwner - currentUserId est null");
        }

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // V√©rifier si le coffre est ouvert en RAM (JS)
            var isOpen = await Crypto.IsVaultOpenAsync(Id);
            if (!isOpen)
            {
                // Si pas ouvert (ex: refresh page), on demande le mot de passe
                _isReopenModalVisible = true;
                StateHasChanged();
            }
        }
    }

    private void OnReopenModalClose()
    {
        _isReopenModalVisible = false;
        StateHasChanged();
    }
    
    private void ShowDeleteModal()
    {
        _isDeleteModalVisible = true;
    }

    private void HideDeleteModal()
    {
        _isDeleteModalVisible = false;
    }

    private async Task ReloadEntriesAsync()
    {
        _entries = await DownstreamApi.GetForUserAsync<List<VaultEntry>>(
            "DownstreamApi",
            o => o.RelativePath = $"/Entry/VaultId?vaultId={Id}"
        ) ?? new();

        StateHasChanged();
    }

    private async Task DeleteVault()
    {
        try
        {
            await DownstreamApi.CallApiForUserAsync(
                "DownstreamApi",
                options =>
                {
                    options.HttpMethod = HttpMethod.Delete.ToString();
                    options.RelativePath = $"/Vault/{Id}";
                });

            _isDeleteModalVisible = false;

            Navigation.NavigateTo("/");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur suppression coffre : {ex.Message}");
        }
    }
    
    private Task OnVaultUpdated()
    {
        return Task.CompletedTask;
    }
}


