@page "/VaultPage/{id:int}"
@inject NavigationManager Navigation
@inject Microsoft.Identity.Abstractions.IDownstreamApi DownstreamApi
@using front_gestionnaire_mot_de_passe.Components.Displayer
@using front_gestionnaire_mot_de_passe.Components.CreateVaultEntryModal
@using front_gestionnaire_mot_de_passe.Models
@using front_gestionnaire_mot_de_passe.Components.DeleteVaultModal
@using front_gestionnaire_mot_de_passe.Components.EditMembers
@using front_gestionnaire_mot_de_passe.Components.OpenVaultModal
@using front_gestionnaire_mot_de_passe.Services
@inject front_gestionnaire_mot_de_passe.Interop.CryptoInterop Crypto
@inject VaultState VaultState
@using front_gestionnaire_mot_de_passe.Components.UpdateVaultModal
@using front_gestionnaire_mot_de_passe.Components.LogsModal
@using front_gestionnaire_mot_de_passe.Models.VaultMembers
@using Microsoft.AspNetCore.Components.Authorization
@inject AuthenticationStateProvider AuthenticationStateProvider
@rendermode InteractiveServer


    <PageTitle>Détails du coffre</PageTitle>


    <section class="menu_vault">
        <div class="menu_vault_top">
            <button type="button" class="menu_button_create" @onclick="ShowModal">+</button>            
            <CreateVaultEntryModal IsVisible="@_isModalVisible"
                                   VaultId="@Id"
                                   OnClose="HideModal"
                                   OnCreated="ReloadEntriesAsync" />
            
            @if (VaultData != null && VaultData.IsOwner)
            {
                <button @onclick="() => _isEditingMembers = true" class="menu_button_share">Gérer les membres</button>
            }
        </div>

        <h2 class="menu_title">Votre coffre fort @(VaultData?.Name)</h2>

        <div class="menu_vault_bottom">
            
        @if (VaultData != null && VaultData.IsOwner)
        {
            <button class="menu_button_update_vault"
                    @onclick="ShowLogsModal">
                Logs
            </button>
            <button class="menu_button_update_vault"
                    @onclick="ShowUpdateVaultModal">
                Modifier coffre
            </button>
        }
        
        @if (VaultData != null && VaultData.IsOwner)
        {
            <button type="button" class="menu_button_delete_vault" @onclick="ShowDeleteModal">Supprimer coffre-fort</button>
        }
        </div>
    </section>
    
    <h3 class="vault_title">Liste des mots de passe</h3>

    <UpdateVaultModal IsVisible="@_isUpdateVaultModalVisible"
                      VaultId="@Id"
                      OnClose="HideUpdateVaultModal"
                      OnUpdated="OnVaultUpdated" />

    <LogsModal IsVisible="@_isLogsModalVisible"
               Logs="@_logs"
               OnClose="HideLogsModal" />

    @if (_isEditingMembers)
    {
        <ModalEditMembers VaultId="@Id" OnClose="@(() => _isEditingMembers = false)" />
    }
    
<section class="display_entries_zone">
    @if (_entries is null)
    {
        <p>Chargement…</p>
    }
    else if (_entries.Count == 0)
    {
        <p>Aucune entrée.</p>
    }
    else
    {
        @foreach (var e in _entries)
        {
            <Displayer Entry="e" VaultId="@Id" OnDeleted="ReloadEntriesAsync" OnUpdated="ReloadEntriesAsync" IsOwner="@(VaultData?.IsOwner ?? false)"/>
        }
    }
</section>

    <DeleteVaultModal IsVisible="@_isDeleteModalVisible"
                      OnClose="HideDeleteModal"
                      OnConfirm="DeleteVault" />

@if (_isReopenModalVisible)
{
    <OpenVaultModal IsVisible="true"
                    VaultId="@Id"
                    VaultData="@VaultData"
                    VaultSalt="@VaultData?.Salt"
                    VaultIterations="@VaultData?.NbIteration"
                    OnClose="OnReopenModalClose" />
}

@code {
    [Parameter] public int Id { get; set; }
    private Vault? VaultData { get; set; }
    private List<Log>? _logs { get; set; }
   
    private bool _isModalVisible;
    private bool _isDeleteModalVisible;
    private bool _isReopenModalVisible;
    private List<VaultEntry>? _entries;
    private bool _isUpdateVaultModalVisible;
    private bool _isLogsModalVisible;
    private bool _isEditingMembers;


    private void ShowModal()
    {
        _isModalVisible = true;
    }
    
    private void HideModal() => _isModalVisible = false;
    
    private void ShowUpdateVaultModal()
    {
        _isUpdateVaultModalVisible = true;
    }
    
    private void HideUpdateVaultModal()
    {
        _isUpdateVaultModalVisible = false;
    }

    protected override async Task OnInitializedAsync()
    {
        // Récupérer tous les coffres (propriétaire + membre)
        var allVaults = await DownstreamApi.GetForUserAsync<List<Vault>>(
            "DownstreamApi",
            o => o.RelativePath = "/Vault/All"
        ) ?? new();

        VaultData = allVaults.FirstOrDefault(v => v.Id == Id);

        _entries = await DownstreamApi.GetForUserAsync<List<VaultEntry>>(
            "DownstreamApi",
            o => o.RelativePath = $"/Entry/VaultId?vaultId={Id}"
        ) ?? new();

        if (VaultData != null)
        {
            // Par défaut, on ne considère pas owner tant qu'on n'a pas vérifié
            VaultData.IsOwner = false;
            
            try 
            {
                // Récupération de l'utilisateur courant pour obtenir son email/nom
                var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
                var userPrincipal = authState.User;
                var userEmail = userPrincipal.Identity?.Name; 
                
                if (!string.IsNullOrEmpty(userEmail))
                {
                    // Récupérer tous les utilisateurs pour trouver l'ID correspondant à notre email
                    var users = await DownstreamApi.GetForUserAsync<List<GetUserObj>>(
                        "DownstreamApi",
                        o => o.RelativePath = "/Users"
                    );

                    // Trouver notre utilisateur interne
                    var me = users?.FirstOrDefault(u => u.Email.Equals(userEmail, StringComparison.OrdinalIgnoreCase));
                    
                    if (me != null)
                    {
                        // Comparer l'ID du créateur du coffre avec notre ID
                        VaultData.IsOwner = (VaultData.UserId == me.Id);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors de la vérification du propriétaire : {ex.Message}");
            }
        }

        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Vérifier si le coffre est ouvert en RAM (JS)
            var isOpen = await Crypto.IsVaultOpenAsync(Id);
            if (!isOpen)
            {
                // Si pas ouvert (ex: refresh page), on demande le mot de passe
                _isReopenModalVisible = true;
                StateHasChanged();
            }
        }
    }

    private void OnReopenModalClose()
    {
        _isReopenModalVisible = false;
        StateHasChanged();
    }
    
    private void ShowDeleteModal()
    {
        _isDeleteModalVisible = true;
    }

    private void HideDeleteModal()
    {
        _isDeleteModalVisible = false;
    }

    private async Task ReloadEntriesAsync()
    {
        _entries = await DownstreamApi.GetForUserAsync<List<VaultEntry>>(
            "DownstreamApi",
            o => o.RelativePath = $"/Entry/VaultId?vaultId={Id}"
        ) ?? new();

        StateHasChanged();
    }

    private async Task ShowLogsModal()
    {
        try
        {
            _logs = await DownstreamApi.GetForUserAsync<List<Log>>(
                "DownstreamApi",
                o => o.RelativePath = $"/Vault/GetLogVault/{Id}"
            ) ?? new();
            
            _isLogsModalVisible = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur récupération logs : {ex.Message}");
        }
    }

    private void HideLogsModal()
    {
        _isLogsModalVisible = false;
    }

    private async Task DeleteVault()
    {
        try
        {
            await DownstreamApi.CallApiForUserAsync(
                "DownstreamApi",
                options =>
                {
                    options.HttpMethod = HttpMethod.Delete.ToString();
                    options.RelativePath = $"/Vault/{Id}";
                });

            _isDeleteModalVisible = false;

            Navigation.NavigateTo("/");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur suppression coffre : {ex.Message}");
        }
    }
    
    private Task OnVaultUpdated()
    {
        return Task.CompletedTask;
    }
}


