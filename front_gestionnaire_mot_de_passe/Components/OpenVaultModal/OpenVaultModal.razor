@using front_gestionnaire_mot_de_passe.Models
@using front_gestionnaire_mot_de_passe.Services
@using Microsoft.AspNetCore.Authorization
@inject Microsoft.Identity.Web.ITokenAcquisition TokenAcquisition
@inject Interop.CryptoInterop Crypto
@inject NavigationManager Nav
@inject VaultState VaultState
@attribute [Authorize]

@if (IsVisible)
{
    <div class="modal-backdrop" @onclick="CloseModal">
        <div class="modal-content" @onclick:stopPropagation="true">
            <h2>Veuillez saisir le mot de passe maître</h2>

            <div class="form-group">
                <label>Mot de passe maître</label>
                <input id="vault-master-pwd"
                       type="password"
                       autocomplete="current-password" />
            </div>

            <div class="modal-actions">
                <button type="button" @onclick="SubmitForm">Ouvrir</button>
                <button type="button" @onclick="CloseModal">Annuler</button>
            </div>

            @if (!string.IsNullOrEmpty(_errorMessage))
            {
                <p style="color:red;">@_errorMessage</p>
            }
        </div>
    </div>
}

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public int? VaultId { get; set; }
    [Parameter] public string? VaultSalt { get; set; } = "";
    [Parameter] public int? VaultIterations { get; set; }
    [Parameter, EditorRequired]
    public Vault VaultData { get; set; } = default!;

    private string? _errorMessage;
    private bool _tokenPushed;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!IsVisible) return;
        if (firstRender && !_tokenPushed)
        {
            try
            {
                var token = await TokenAcquisition.GetAccessTokenForUserAsync(new[]
                {
                    "api://b8f83755-0f15-42f5-9a43-cedf7cc50c0a/access_as_user"
                });

                await Crypto.SetApiAccessTokenAsync(token);
                _tokenPushed = true;
            }
            catch (Microsoft.Identity.Web.MicrosoftIdentityWebChallengeUserException)
            {
                // L'utilisateur doit (re)consentir ou se reconnecter → redirige vers la page de login
                Nav.NavigateTo($"authentication/login?returnUrl={Uri.EscapeDataString(Nav.Uri)}", forceLoad: true);
            }
        }
    }

    private async Task SubmitForm()
    {
        _errorMessage = null;

        if (VaultId == null || VaultId <= 0) { _errorMessage = "VaultId manquant."; return; }
        if (string.IsNullOrWhiteSpace(VaultSalt) || VaultIterations <= 0) { _errorMessage = "Paramètres du coffre (salt/iterations) manquants."; return; }

        try
        {
            var ok = await Crypto.OpenVaultFromModalAsync(
                VaultId.Value,
                // ID du champ input dans le modal
                "vault-master-pwd",
                VaultSalt!,
                VaultIterations!.Value
            );

            if (!ok)
            {
                _errorMessage = "Mot de passe incorrect.";
                return;
            }

            await CloseModal();
            
            VaultState.Set(VaultData);
            Nav.NavigateTo($"/VaultPage/{VaultId}");
        }
        catch (Exception ex)
        {
            _errorMessage = $"Erreur : {ex.Message}";
        }
    }

    private async Task CloseModal()
    {
        //_vaultPassword = "";
        if (OnClose.HasDelegate)
            await OnClose.InvokeAsync();
    }
}