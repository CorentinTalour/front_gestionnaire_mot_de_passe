@using front_gestionnaire_mot_de_passe.Models
@using front_gestionnaire_mot_de_passe.Components.UpdateVaultEntryModal
@using front_gestionnaire_mot_de_passe.Services
@inject Interop.CryptoInterop Crypto
@inject Microsoft.Identity.Abstractions.IDownstreamApi DownstreamApi
@inject IEntryService EntryService
@rendermode InteractiveServer

<div class="display-card">
    <div class="display-card-header">
        <img src="cle_icon.jpg" alt="Ic√¥ne de cl√©" class="vault-key-icon"/>
        <div class="display-info">
            <p><strong>Entr√©e #@Entry.Id</strong></p>
        </div>
    </div>

    @if (IsOwner)
    {
        <div class="display-actions">
            <button class="consult-btn" type="button" @onclick="ShowUpdateModal">Modifier</button>
        </div>
    }

    <div class="display-actions">
        <button class="consult-btn" type="button" @onclick="OpenModalAsync">Consulter</button>
    </div>
</div>

@if (_showModal)
{
    <div class="modal-layout" @onclick="CloseModal">
        <section class="entry-details" @onclick:stopPropagation="true">
            <div class="entry-button">
                <button class="entry-back-button" type="button" @onclick="CloseModal">
                    ‚Üê Retour au coffre
                </button>

                @if (IsOwner)
                {
                    <button class="entry-back-button" type="button" @onclick="DeleteVaultEntry">
                        Supprimer l'√©l√©ment
                    </button>
                }
            </div>

            <div class="entry-card">
                <h2><span id="@DomId("name")">‚Ä¶</span></h2>

                <p>
                    <strong>Nom d'utilisateur :</strong>
                    <span id="@DomId("username")">‚Ä¶</span>
                </p>

                <div class="pwd-row">
                    <div class="pwd-left">
                        <strong>Mot de passe :</strong>
                        <span id="@DomId("password")">@(_passwordDecrypted ? "" : "Cliquez sur l'≈ìil ou Copier")</span>
                    </div>

                    <div class="pwd-actions">
                        <button type="button" class="toggle-btn" @onclick="TogglePasswordAsync">üëÅÔ∏è</button>
                        <button type="button" class="copy-btn" @onclick="CopyPasswordAsync">Copier</button>
                    </div>
                </div>

                <p>
                    <strong>Note :</strong>
                    <span id="@DomId("notes")">‚Ä¶</span>
                </p>

                <p>
                    <strong>URL :</strong>
                    <span id="@DomId("url")">‚Ä¶</span>
                </p>

                <p><strong>Cr√©√© le :</strong> @Entry.CreatedAt.ToString("g")</p>
                <p><strong>Mis √† jour le :</strong> @(FormatUpdatedAt())</p>
                <p><strong>ID du coffre :</strong> @Entry.VaultId</p>

                @if (!string.IsNullOrWhiteSpace(_error))
                {
                    <p class="error-text">@_error</p>
                }
            </div>

            @if (_oldEntries?.Any() == true)
            {
                <h3>Historique (@_oldEntries.Count version(s))</h3>
                @foreach (var e in _oldEntries)
                {
                    <div class="old-entry-card">
                        <h4>Version modifi√©e le @e.ModifiedAt.ToString("g")</h4>
                        <p><strong>Nom :</strong> <span id="entry-@e.Id-name">‚Ä¶</span></p>
                        <p><strong>Nom d'utilisateur :</strong> <span id="entry-@e.Id-username">‚Ä¶</span></p>
                        
                        <div class="pwd-row">
                            <div class="pwd-left">
                                <strong>Mot de passe :</strong>
                                <span id="entry-@e.Id-password">Cliquez sur l'≈ìil ou Copier</span>
                            </div>
                            <div class="pwd-actions">
                                <button type="button" class="toggle-btn" @onclick="() => ToggleHistoryPasswordAsync(e.Id)">üëÅÔ∏è</button>
                                <button type="button" class="copy-btn" @onclick="() => CopyHistoryPasswordAsync(e.Id)">Copier</button>
                            </div>
                        </div>
                        
                        <p><strong>URL :</strong> <span id="entry-@e.Id-url">‚Ä¶</span></p>
                        <p><strong>Note :</strong> <span id="entry-@e.Id-notes">‚Ä¶</span></p>
                    </div>
                }
            }
            else if (_oldEntries != null && _oldEntries.Count == 0)
            {
                <p style="color: #888; font-style: italic; margin-top: 1rem;">
                    Aucun historique : cette entr√©e n'a jamais √©t√© modifi√©e.
                </p>
            }
        </section>
    </div>
}
<UpdateVaultEntryModal IsVisible="@_isUpdateModalVisible"
                       EntryId="@Entry.Id"
                       Entry="@Entry"
                       OnClose="HideUpdateModal"
                       OnUpdated="HandleEntryUpdated" />

@code {
    [Parameter, EditorRequired] public VaultEntry Entry { get; set; } = default!;
    [Parameter] public int VaultId { get; set; }
    [Parameter] public bool IsOwner { get; set; }
    [Parameter] public EventCallback OnDeleted { get; set; }
    [Parameter] public EventCallback OnUpdated { get; set; }

    private bool _showModal;
    private bool _needDecrypt;
    private bool _needDecryptHistory; // Flag pour d√©chiffrer les champs de l'historique (sauf passwords)
    private string? _error;
    private bool _isUpdateModalVisible;
    private List<VaultEntry>? _oldEntries;
    private bool _passwordDecrypted;

    private readonly string _uid = Guid.NewGuid().ToString("N");
    private string DomId(string field) => $"entry-{Entry.Id}-{_uid}-{field}";

    private async Task OpenModalAsync()
    {
        // Ouverture de la modale
        _error = null;
        _showModal = true;
        _needDecrypt = true;
        _needDecryptHistory = false;

        try
        {
            Console.WriteLine($"R√©cup√©ration de l'historique pour l'entr√©e {Entry.Id}...");
            Console.WriteLine($"URL: /Entry/{Entry.Id}");
            
            try
            {
                _oldEntries = await EntryService.GetEntryHistoryAsync(Entry.Id);
                
                Console.WriteLine($"Historique r√©cup√©r√© avec VaultEntryHistory : {_oldEntries.Count} version(s)");
            }
            catch (Exception historyEx)
            {
                Console.WriteLine($"Impossible de d√©s√©rialiser en VaultEntryHistory : {historyEx.Message}");
            }
            
            if (_oldEntries != null && _oldEntries.Count == 0)
            {
                Console.WriteLine("Aucune version d'historique trouv√©e pour cette entr√©e");
            }
            else
            {
                Console.WriteLine($"Versions d'historique :");
                if (_oldEntries != null)
                    foreach (var entry in _oldEntries)
                    {
                        Console.WriteLine($"  - ID: {entry.Id}, Modifi√© le: {entry.ModifiedAt}");
                    }

                // Activer le d√©chiffrement de l'historique
                _needDecryptHistory = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur lors de la r√©cup√©ration de l'historique : {ex.Message}");
            Console.WriteLine($"Stack trace : {ex.StackTrace}");
            _error = ex.Message;
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ShowUpdateModal()
    {
        _isUpdateModalVisible = true;
    }

    private async Task HideUpdateModal()
    {
        _isUpdateModalVisible = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleEntryUpdated()
    {
        _isUpdateModalVisible = false;
        if (OnUpdated.HasDelegate)
        {
            await OnUpdated.InvokeAsync();
        }
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_showModal && _needDecrypt)
        {
            _needDecrypt = false;

            try
            {
                // D√©chiffrer tous les champs SAUF le mot de passe
                await Crypto.DecryptEntryToDomAsync(VaultId, Entry, new
                {
                    nameId = DomId("name"),
                    usernameId = DomId("username"),
                    passwordId = (string)null!, // Ne pas d√©chiffrer le mot de passe
                    urlId = DomId("url"),
                    notesId = DomId("notes")
                });
            }
            catch (Exception ex)
            {
                _error = ex.Message;
                await InvokeAsync(StateHasChanged);
            }
        }

        // D√©chiffrer l'historique quand il est disponible
        if (_showModal && _needDecryptHistory && _oldEntries?.Any() == true)
        {
            _needDecryptHistory = false;
            
            try
            {
                Console.WriteLine($"D√©chiffrement de {_oldEntries.Count} version(s) d'historique...");
                foreach (var e in _oldEntries)
                {
                    Console.WriteLine($"D√©chiffrement de la version ID: {e.Id}");
                    // D√©chiffrer tous les champs SAUF le mot de passe
                    await Crypto.DecryptEntryToDomAsync(VaultId, e, new
                    {
                        nameId = $"entry-{e.Id}-name",
                        usernameId = $"entry-{e.Id}-username",
                        passwordId = (string)null!, // Ne pas d√©chiffrer le mot de passe ici
                        urlId = $"entry-{e.Id}-url",
                        notesId = $"entry-{e.Id}-notes"
                    });
                }
                Console.WriteLine("D√©chiffrement de l'historique termin√©");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Erreur lors du d√©chiffrement de l'historique : {ex.Message}");
                _error = ex.Message;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void CloseModal()
    {
        _error = null;
        _showModal = false;
        _passwordDecrypted = false;
        _needDecryptHistory = false;
        StateHasChanged();
    }

    private async Task GetAndDecryptPasswordAsync()
    {
        if (_passwordDecrypted)
            return;

        try
        {
            var success = await Crypto.FetchAndDecryptPasswordAsync(
                VaultId, 
                Entry.Id, 
                DomId("password")
            );

            if (!success)
            {
                _error = "Impossible de r√©cup√©rer le mot de passe";
                await InvokeAsync(StateHasChanged);
                return;
            }

            _passwordDecrypted = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = $"Erreur lors de la r√©cup√©ration du mot de passe : {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CopyPasswordAsync()
    {
        try
        {
            // R√©cup√©rer et d√©chiffrer le mot de passe si ce n'est pas d√©j√† fait
            await GetAndDecryptPasswordAsync();
            
            if (!_passwordDecrypted)
            {
                _error = "Impossible de copier le mot de passe";
                return;
            }

            await Crypto.CopyDomTextToClipboardAsync(DomId("password"));
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private string FormatUpdatedAt()
    {
        var prop = Entry.GetType().GetProperty("UpdatedAt");
        var val = prop?.GetValue(Entry);

        if (val is DateTime dt) return dt.ToString("g");
        if (val is DateTimeOffset dto) return dto.LocalDateTime.ToString("g");

        return val?.ToString() ?? "Aucune mise √† jour";
    }

    private async Task TogglePasswordAsync()
    {
        try
        {
            // R√©cup√©rer et d√©chiffrer le mot de passe si ce n'est pas d√©j√† fait
            await GetAndDecryptPasswordAsync();
            
            if (!_passwordDecrypted)
            {
                _error = "Impossible d'afficher le mot de passe";
                return;
            }

            await Crypto.TogglePasswordVisibilityAsync(DomId("password"));
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task DeleteVaultEntry()
    {
        _error = null;

        try
        {
            HttpResponseMessage res = await DownstreamApi.CallApiForUserAsync(
                "DownstreamApi",
                options =>
                {
                    options.HttpMethod = HttpMethod.Delete.Method;
                    options.RelativePath = $"/Entry?entryId={Entry.Id}";
                });

            if (OnDeleted.HasDelegate)
                await OnDeleted.InvokeAsync();

            if (!res.IsSuccessStatusCode)
            {
                string body = await res.Content.ReadAsStringAsync();
                _error = $"DELETE √©chou√©: {(int)res.StatusCode} {res.ReasonPhrase} {body}";
                return;
            }

            CloseModal();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task ToggleHistoryPasswordAsync(int historyId)
    {
        try
        {
            // Trouver l'entr√©e d'historique correspondante
            var historyEntry = _oldEntries?.FirstOrDefault(e => e.Id == historyId);
            if (historyEntry == null)
            {
                _error = "Entr√©e d'historique introuvable";
                return;
            }

            // R√©cup√©rer et d√©chiffrer le mot de passe si pas encore fait
            await Crypto.FetchAndDecryptSingleHistoryPasswordAsync(
                VaultId, 
                Entry.Id, 
                historyEntry.Id, 
                historyEntry.PasswordCypherId
            );

            // Ensuite toggle la visibilit√©
            string passwordId = $"entry-{historyId}-password";
            await Crypto.TogglePasswordVisibilityAsync(passwordId);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CopyHistoryPasswordAsync(int historyId)
    {
        try
        {
            // Trouver l'entr√©e d'historique correspondante
            var historyEntry = _oldEntries?.FirstOrDefault(e => e.Id == historyId);
            if (historyEntry == null)
            {
                _error = "Entr√©e d'historique introuvable";
                return;
            }

            // R√©cup√©rer et d√©chiffrer le mot de passe si pas encore fait
            await Crypto.FetchAndDecryptSingleHistoryPasswordAsync(
                VaultId, 
                Entry.Id, 
                historyEntry.Id, 
                historyEntry.PasswordCypherId
            );

            // Ensuite copier
            string passwordId = $"entry-{historyId}-password";
            await Crypto.CopyDomTextToClipboardAsync(passwordId);
        }
        catch (Exception ex)
        {
            _error = ex.Message;
            await InvokeAsync(StateHasChanged);
        }
    }
}





