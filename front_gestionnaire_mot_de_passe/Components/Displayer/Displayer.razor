@using front_gestionnaire_mot_de_passe.Models
@using front_gestionnaire_mot_de_passe.Components.UpdateVaultEntryModal
@using front_gestionnaire_mot_de_passe.Services
@inject Interop.CryptoInterop Crypto
@inject Microsoft.Identity.Abstractions.IDownstreamApi DownstreamApi
@rendermode InteractiveServer

<div class="display-card">
    <div class="display-card-header">
        <img src="cle_icon.jpg" alt="Ic√¥ne de cl√©" class="vault-key-icon"/>
        <div class="display-info">
            <p><strong>Entr√©e #@Entry.Id</strong></p>
        </div>
    </div>

    @if (IsOwner)
    {
        <div class="display-actions">
            <button class="consult-btn" type="button" @onclick="ShowUpdateModal">Modifier</button>
        </div>
    }

    <div class="display-actions">
        <button class="consult-btn" type="button" @onclick="OpenModalAsync">Consulter</button>
    </div>
</div>

@if (_showModal)
{
    <div class="modal-layout" @onclick="CloseModal">
        <section class="entry-details" @onclick:stopPropagation="true">
            <div class="entry-button">
                <button class="entry-back-button" type="button" @onclick="CloseModal">
                    ‚Üê Retour au coffre
                </button>

                @if (IsOwner)
                {
                    <button class="entry-back-button" type="button" @onclick="DeleteVaultEntry">
                        Supprimer l'√©l√©ment
                    </button>
                }
            </div>

            <div class="entry-card">
                <h2><span id="@DomId("name")">‚Ä¶</span></h2>

                <p>
                    <strong>Nom d'utilisateur :</strong>
                    <span id="@DomId("username")">‚Ä¶</span>
                </p>

                <div class="pwd-row">
                    <div class="pwd-left">
                        <strong>Mot de passe :</strong>
                        <span id="@DomId("password")">@(_passwordDecrypted ? "" : "Cliquez sur l'≈ìil ou Copier")</span>
                    </div>

                    <div class="pwd-actions">
                        <button type="button" class="toggle-btn" @onclick="TogglePasswordAsync">üëÅÔ∏è</button>
                        <button type="button" class="copy-btn" @onclick="CopyPasswordAsync">Copier</button>
                    </div>
                </div>

                <p>
                    <strong>Note :</strong>
                    <span id="@DomId("notes")">‚Ä¶</span>
                </p>

                <p>
                    <strong>URL :</strong>
                    <span id="@DomId("url")">‚Ä¶</span>
                </p>

                <p><strong>Cr√©√© le :</strong> @Entry.CreatedAt.ToString("g")</p>
                <p><strong>Mis √† jour le :</strong> @(FormatUpdatedAt())</p>
                <p><strong>ID du coffre :</strong> @Entry.VaultId</p>

                @if (!string.IsNullOrWhiteSpace(_error))
                {
                    <p class="error-text">@_error</p>
                }
            </div>

            @if (_oldEntries?.Any() == true)
            {
                <h3>Historique</h3>
                @foreach (var e in _oldEntries)
                {
                    <div class="old-entry-card">
                        <h4>Entr√©e #@e.Id</h4>
                        <p><strong>Nom d'utilisateur :</strong> <span id="entry-@e.Id-username">‚Ä¶</span></p>
                        <p><strong>Mot de passe :</strong> <span id="entry-@e.Id-password">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span></p>
                        <p><strong>URL :</strong> <span id="entry-@e.Id-url">‚Ä¶</span></p>
                        <p><strong>Note :</strong> <span id="entry-@e.Id-notes">‚Ä¶</span></p>
                    </div>
                }
            }
        </section>
    </div>
}
<UpdateVaultEntryModal IsVisible="@_isUpdateModalVisible"
                       EntryId="@Entry.Id"
                       Entry="@Entry"
                       OnClose="HideUpdateModal"
                       OnUpdated="HandleEntryUpdated" />

@code {
    [Parameter, EditorRequired] public VaultEntry Entry { get; set; } = default!;
    [Parameter] public int VaultId { get; set; }
    [Parameter] public bool IsOwner { get; set; }
    [Parameter] public EventCallback OnDeleted { get; set; }
    [Parameter] public EventCallback OnUpdated { get; set; }

    private bool _showModal;
    private bool _needDecrypt;
    private string? _error;
    private bool _isUpdateModalVisible;
    private List<VaultEntry>? _oldEntries;
    private bool _passwordDecrypted;

    private readonly string _uid = Guid.NewGuid().ToString("N");
    private string DomId(string field) => $"entry-{Entry.Id}-{_uid}-{field}";

    private async Task OpenModalAsync()
    {
        // Ouverture de la modale
        _error = null;
        _showModal = true;
        _needDecrypt = true;

        try
        {
            _oldEntries = await DownstreamApi.GetForUserAsync<List<VaultEntry>>(
                "DownstreamApi",
                o => o.RelativePath = $"/Entry/{Entry.Id}"
            ) ?? new();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private void ShowUpdateModal()
    {
        _isUpdateModalVisible = true;
    }

    private async Task HideUpdateModal()
    {
        _isUpdateModalVisible = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task HandleEntryUpdated()
    {
        _isUpdateModalVisible = false;
        if (OnUpdated.HasDelegate)
        {
            await OnUpdated.InvokeAsync();
        }
        await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_showModal && _needDecrypt)
        {
            _needDecrypt = false;

            try
            {
                // D√©chiffrer tous les champs SAUF le mot de passe
                await Crypto.DecryptEntryToDomAsync(VaultId, Entry, new
                {
                    nameId = DomId("name"),
                    usernameId = DomId("username"),
                    passwordId = (string)null!, // Ne pas d√©chiffrer le mot de passe
                    urlId = DomId("url"),
                    notesId = DomId("notes")
                });
            }
            catch (Exception ex)
            {
                _error = ex.Message;
                await InvokeAsync(StateHasChanged);
            }

            try
            {
                if (_oldEntries?.Any() == true)
                {
                    foreach (var e in _oldEntries)
                    {
                        await Crypto.DecryptEntryToDomAsync(VaultId, e, new
                        {
                            nameId = $"entry-{e.Id}-name",
                            usernameId = $"entry-{e.Id}-username",
                            passwordId = $"entry-{e.Id}-password",
                            urlId = $"entry-{e.Id}-url",
                            notesId = $"entry-{e.Id}-notes"
                        });
                    }
                }
                else
                {
                    Console.WriteLine("ya rien");
                }
            }
            catch (Exception ex)
            {
                _error = ex.Message;
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private void CloseModal()
    {
        _error = null;
        _showModal = false;
        _passwordDecrypted = false;
        StateHasChanged();
    }

    private async Task GetAndDecryptPasswordAsync()
    {
        if (_passwordDecrypted)
            return;

        try
        {
            // ‚ö†Ô∏è S√âCURIT√â : L'appel se fait directement en JavaScript
            // Le mot de passe chiffr√© est r√©cup√©r√© depuis l'API c√¥t√© client
            // Le d√©chiffrement se fait enti√®rement c√¥t√© client
            // Le mot de passe en clair ne transite JAMAIS c√¥t√© serveur C#
            var success = await Crypto.FetchAndDecryptPasswordAsync(
                VaultId, 
                Entry.Id, 
                DomId("password")
            );

            if (!success)
            {
                _error = "Impossible de r√©cup√©rer le mot de passe";
                await InvokeAsync(StateHasChanged);
                return;
            }

            _passwordDecrypted = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            _error = $"Erreur lors de la r√©cup√©ration du mot de passe : {ex.Message}";
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task CopyPasswordAsync()
    {
        try
        {
            // R√©cup√©rer et d√©chiffrer le mot de passe si ce n'est pas d√©j√† fait
            await GetAndDecryptPasswordAsync();
            
            if (!_passwordDecrypted)
            {
                _error = "Impossible de copier le mot de passe";
                return;
            }

            await Crypto.CopyDomTextToClipboardAsync(DomId("password"));
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private string FormatUpdatedAt()
    {
        var prop = Entry.GetType().GetProperty("UpdatedAt");
        var val = prop?.GetValue(Entry);

        if (val is DateTime dt) return dt.ToString("g");
        if (val is DateTimeOffset dto) return dto.LocalDateTime.ToString("g");

        return val?.ToString() ?? "Aucune mise √† jour";
    }

    private async Task TogglePasswordAsync()
    {
        try
        {
            // R√©cup√©rer et d√©chiffrer le mot de passe si ce n'est pas d√©j√† fait
            await GetAndDecryptPasswordAsync();
            
            if (!_passwordDecrypted)
            {
                _error = "Impossible d'afficher le mot de passe";
                return;
            }

            await Crypto.TogglePasswordVisibilityAsync(DomId("password"));
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }

    private async Task DeleteVaultEntry()
    {
        _error = null;

        try
        {
            HttpResponseMessage res = await DownstreamApi.CallApiForUserAsync(
                "DownstreamApi",
                options =>
                {
                    options.HttpMethod = HttpMethod.Delete.Method;
                    options.RelativePath = $"/Entry?entryId={Entry.Id}";
                });

            if (OnDeleted.HasDelegate)
                await OnDeleted.InvokeAsync();

            if (!res.IsSuccessStatusCode)
            {
                string body = await res.Content.ReadAsStringAsync();
                _error = $"DELETE √©chou√©: {(int)res.StatusCode} {res.ReasonPhrase} {body}";
                return;
            }

            CloseModal();
        }
        catch (Exception ex)
        {
            _error = ex.Message;
        }
    }
}